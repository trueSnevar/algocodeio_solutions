"""
Возрастающая подпоследовательность

легко
решено

Дан массив nums. Нужно вернуть длину самой длинной непрерывной возрастающей подпоследовательности.

Непрерывная возрастающая подпоследовательность – подряд идущие элементы,
где каждый следующий элемент строго больше предыдущего.

Пример 1:

Ввод: nums = [1,8,7,15,21,22,1,7,2]
Вывод: 4
Объяснение: [7,15,21,22]

Пример 2:

Ввод: nums = [3,3,3]
Вывод: 1
Объяснение: возрастающая подпоследовательность не может включать равные элементы.

Пример 3:

Ввод: nums = [1,3,5,7]
Вывод: 4

Ограничения:

len(nums) >= 1

"""

from typing import *

def find_length(nums: List[int]) -> int:
    max_length = 1 # максимальная длина возрастающей последовательности
    curr_length = 1 # текущая длина возрастающей последовательности
    for i in range(1, len(nums)):
        prev = nums[i - 1]
        # т.к. последовательность по условию непрерывная,
        # то мы на каждой итерации или увеличиваем ответ - если
        # приходит число больше чем предыдущее, или делаем ответ 1,
        # т.к. непрерывная возрастающая последовательности кончилась
        # и мы начинаем новую возрастающую последовательность
        if prev < nums[i]:
            curr_length += 1
        else:
            curr_length = 1
        # на каждой итерации обновляем ответ
        max_length = max(max_length, curr_length)
    return max_length


if __name__ == "__main__":
    ex1 = [1,8,7,15,21,22,1,7,2]
    ex2 = [3,3,3]
    ex3 = [1,3,5,7]

    ans1 = find_length(ex1)
    ans2 = find_length(ex2)
    ans3 = find_length(ex3)
    print(ans1)
    print(ans2)
    print(ans3)

"""
Оценка сложности

Время: O(n), где n - длина массива nums
Память: O(1)
"""