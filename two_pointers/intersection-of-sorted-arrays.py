"""
Общие элементы массивов

легко
решено

Даны два отсортированных по возрастанию массива nums1 и nums2.
Необходимо вернуть новый массив nums3, содержащий все общие элементы из nums1 и nums2.

Результат также должен быть отсортирован по возрастанию. Если элемент встречается
в обоих массивах несколько раз, он должен появиться в результате столько раз,
сколько раз он встречается в обоих.

Пример 1:

Ввод: nums1 = [-3,2,2,5,8,19,31], nums2 = [1,2,2,2,6,19,52]
Вывод: [2,2,19]

Пример 2:

Ввод: nums1 = [-5,4], nums2 = [1,2]
Вывод: []

Пример 3:

Ввод: nums1 = [], nums2 = [1,2]
Вывод: []

Ограничения:
- len(nums1), len(nums2) ≥ 0
- nums1 и nums2 отсортированы по возрастанию
"""
from typing import List


def intersect_sorted(nums1: List[int], nums2: List[int]) -> List[int]:
    """
    Возвращает массив общих элементов двух отсортированных массивов,
    учитывая дубликаты, за O(n + m) времени и O(1) дополнительной памяти.
    """
    p1 = 0
    p2 = 0

    res = []

    while p1 < len(nums1) and p2 < len(nums2):
        n1 = nums1[p1]
        n2 = nums2[p2]

        if n1 < n2:
            p1 += 1
        elif n1 > n2:
            p2 += 1
        else:
            res.append(n1)
            p1 += 1
            p2 += 1

    return res


if __name__ == "__main__":
    # Пример 1
    print(intersect_sorted([-3,2,2,5,8,19,31], [1,2,2,2,6,19,52]))  # [2,2,19]
    # Пример 2
    print(intersect_sorted([-5,4], [1,2]))                        # []
    # Пример 3
    print(intersect_sorted([], [1,2]))                             # []

# Оценка сложности:
# Время: O(n + m), где n = len(nums1), m = len(nums2)
# Память: O(k), где k — размер выходного массива (дополнительная память O(1))
