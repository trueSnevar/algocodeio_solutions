"""
Сумма в сортированном массиве

легко
решено

Дан отсортированный массив nums и число target. Нужно вернуть позиции двух чисел,
которые в сумме дают target. Ответ гарантированно существует и единственен.

Индексация в массиве начинается с 1. Нужно вернуть сначала меньший индекс, затем больший.

ВАЖНО: решение должно использовать O(1) дополнительной памяти.

Пример 1:

Ввод: nums = [-2,1,6,9,12], target = 18
Вывод: [3,5]

Объяснение: 6 + 12 = 18, индексы 6→3, 12→5.

Пример 2:

Ввод: nums = [3,3,12], target = 6
Вывод: [1,2]

Объяснение: 3 + 3 = 6, индексы 1 и 2.

Ограничения:
- len(nums) ≥ 2
- nums отсортирован в неубывающем порядке
- Ответ единственный и существует
"""
from typing import List


def two_sum_sorted(nums: List[int], target: int) -> List[int]:
    """
    Возвращает [i, j] такие, что nums[i-1] + nums[j-1] == target,
    используя два указателя с O(1) памяти.
    """
    left, right = 0, len(nums) - 1
    while left < right:
        cur = nums[left] + nums[right]
        if cur == target:
            # возвращаем индексы 1-based
            return [left + 1, right + 1]
        elif cur < target:
            left += 1
        else:
            right -= 1
    # по условию всегда есть решение
    return []


if __name__ == "__main__":
    # Пример 1
    print(two_sum_sorted([-2, 1, 6, 9, 12], 18))  # [3,5]
    # Пример 2
    print(two_sum_sorted([3, 3, 12], 6))          # [1,2]

# Оценка сложности:
# Время: O(n), где n = len(nums)
# Память: O(1) дополнительной памяти
