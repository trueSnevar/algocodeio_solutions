"""
Симметричная разница массивов

средне
решено

Даны два массива nums1 и nums2, отсортированные по возрастанию и состоящие из уникальных элементов.
Нужно найти все элементы, которые встречаются только в одном из массивов, и вернуть их в порядке возрастания.

Пример 1:

Ввод: nums1 = [1,5,7,9], nums2 = [2,3,5,6,7,8]
Вывод: [1,2,3,6,8,9]

Пример 2:

Ввод: nums1 = [2,3], nums2 = [1]
Вывод: [1,2,3]

Ограничения:
- Массивы nums1 и nums2 отсортированы и содержат уникальные элементы
- len(nums1) + len(nums2) ≥ 1
"""
from typing import List


def symmetric_difference(nums1: List[int], nums2: List[int]) -> List[int]:
    """
    Возвращает отсортированный массив элементов, которые присутствуют ровно в одном из nums1 или nums2.
    Использует два указателя за O(n+m) времени и O(1) доп. памяти.
    """
    result = []
    p1 = 0
    p2 = 0

    while p1 < len(nums1) or p2 < len(nums2):
        # если вышли за границу nums2, значит нужно
        #   добавить оставшиеся элементы из nums1
        if p2 >= len(nums2):
            result.append(nums1[p1])
            p1 += 1
            continue
        # если вышли за границу nums1, значит нужно
        #   добавить оставшиеся элементы из nums2
        if p1 >= len(nums1):
            result.append(nums2[p2])
            p2 += 1
            continue

        # меньшее значение добавляем в ответ, а если
        #  указатели равны, то двигаем оба указателя
        if nums1[p1] < nums2[p2]:
            result.append(nums1[p1])
            p1 += 1
        elif nums1[p1] > nums2[p2]:
            result.append(nums2[p2])
            p2 += 1
        else:
            p1 += 1
            p2 += 1
    return result


if __name__ == "__main__":
    # Пример 1
    print(symmetric_difference([1,5,7,9], [2,3,5,6,7,8]))  # [1,2,3,6,8,9]
    # Пример 2
    print(symmetric_difference([2,3], [1]))             # [1,2,3]

# Оценка сложности:
# Время: O(n + m), где n = len(nums1), m = len(nums2)
# Память: O(k), где k — размер выходного массива (доп. память O(1))
