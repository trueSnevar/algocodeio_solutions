"""
Раскраска по номерам

легко
решено

Дана раскраска по номерам в виде двумерного массива grid.
Нужно определить минимальное количество заливок, необходимых, чтобы «закрасить» всю картину.

Когда мы делаем «заливку» (например, в графическом редакторе), мы выбираем клетку,
и одновременно «заливаются» все соседние клетки того же цвета.
Соседними считаем клетки сверху, снизу, слева и справа.

Пример 1:

Ввод: grid =
[[1,1,1,1,1,1,1,1]
,[1,2,2,1,1,2,2,1]
,[1,2,1,2,2,1,2,1]
,[1,2,2,2,2,2,2,1]
,[1,1,1,1,1,1,1,1]]
Вывод: 4

Ограничения:

len(grid) >= 1
len(grid[i]) >= 1
"""

from typing import *


def draw(grid: List[List[int]]) -> int:
    ROWS = len(grid)
    COLS = len(grid[0])
    dirs = [(1, 0), (0, 1), (-1, 0), (0, -1)]
    visited = set()
    ans = 0

    def dfs(r, c):
        visited.add((r, c))
        for dr, dc in dirs:
            nr = dr + r
            nc = dc + c
            if (
                nr in range(ROWS) and
                nc in range(COLS) and
                (nr, nc) not in visited and
                grid[nr][nc] == grid[r][c]
            ):
                dfs(nr, nc)

    for i in range(ROWS):
        for j in range(COLS):
            if (i, j) not in visited:
                dfs(i, j)
                ans += 1

    return ans

if __name__ == "__main__":
    ex1 = [[1, 1, 1, 1, 1, 1, 1, 1]
        , [1, 2, 2, 1, 1, 2, 2, 1]
        , [1, 2, 1, 2, 2, 1, 2, 1]
        , [1, 2, 2, 2, 2, 2, 2, 1]
        , [1, 1, 1, 1, 1, 1, 1, 1]]

    ans1 = draw(ex1)

    print(ans1)



"""
Оценка сложности

Время: O(n * m), где n кол-во строк и m кол-во столбцов входного массива
Память: O(n * m), где n кол-во строк и m кол-во столбцов входного массива
"""