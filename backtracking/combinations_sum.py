"""
Сумма комбинаций

средне
решено

Дан массив положительных чисел nums и число x.
Нужно найти все способы сложить числа из массива так, чтобы в сумме получилось x.
Каждое число можно использовать сколько угодно раз.

Две комбинации считаются разными, если хотя бы одно число встречается в них разное количество раз.

Пример 1:

Ввод: nums = [2,3,6,7], x = 7
Вывод: [[2,2,3],[7]]
Объяснение: 2 + 2 + 3 = 7 — можно использовать 2 несколько раз. 7 уже равно x, поэтому это тоже подходит. Это единственные возможные комбинации.

Пример 2:

Ввод: nums = [1,2,2,3], x = 6
Вывод: [[2,2,2],[3,3],[3,2,1],[1,1,1,1,1,1],[1,1,1,1,2],[1,1,2,2],[1,1,1,3]]

Пример 3:

Ввод: nums = [9], x = 1
Вывод: []

Ограничения:

len(nums) >= 1
"""

from typing import *


def combinations(nums: List[int], x: int) -> List[List[int]]:
    res = []
    nums = sorted(set(nums))  # чтобы избежать дубликатов в ответе

    def backtrack(idx: int, nums: List[int], subset: List[int], target: int):
        # 1) если ровно в ноль — сохраняем решение
        if target == 0:
            res.append(subset[:])
            return
        # 2) если вышли за границы или «перепрыгнули» в минус — больше нечего искать
        if target < 0 or idx == len(nums):
            return

        # пропускаем текущий элемент
        backtrack(idx + 1, nums, subset, target)

        # берем текущий элемент
        subset.append(nums[idx])
        backtrack(idx, nums, subset, target - nums[idx])
        subset.pop()

    backtrack(0, nums, [], x)
    return res

if __name__ == "__main__":
    ex1 = [2,3,6,7]
    x1 = 7

    ex2 = [1,2,2,3]
    x2 = 6

    ex3 = [9]
    x3 = 1

    ans1 = combinations(ex1, x1)
    ans2 = combinations(ex2, x2)
    ans3 = combinations(ex3, x3)

    print(ans1)
    print(ans2)
    print(ans3)



"""
Оценка сложности

Время: O(n*n^(x/min(nums))), 
где n — размер nums, 
x — число, сумму которого ищем, а min(nums) минимальное значение в массиве nums.

Память: O(n*n^(x/min(nums)))

x/min(nums) — это максимальная глубина стека, при переборе всех вариантов. 
В каждой рекурсивной ветке мы перебираем максимум n возможных чисел, отсюда и возникает оценка O(n*n^(x/min(nums))).
"""
